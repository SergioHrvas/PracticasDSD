/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "dir.h"

tipo_simple *
suma_1_svc(operacion arg1,  struct svc_req *rqstp)
{
	static tipo_simple  result;
	result.tipo_simple_u.resultado = arg1.firstparam + arg1.secondparam;
	/*
	 * insert server code here
	 */

	return &result;
}

tipo_simple *
resta_1_svc(operacion arg1,  struct svc_req *rqstp)
{
	static tipo_simple  result;
	result.tipo_simple_u.resultado = arg1.firstparam - arg1.secondparam;
	/*
	 * insert server code here
	 */

	return &result;
}

tipo_simple *
multiplicacion_1_svc(operacion arg1,  struct svc_req *rqstp)
{
	static tipo_simple  result;
	result.tipo_simple_u.resultado = arg1.firstparam * arg1.secondparam;
	/*
	 * insert server code here
	 */

	return &result;
}

tipo_simple *
division_1_svc(operacion arg1,  struct svc_req *rqstp)
{
	static tipo_simple  result;
	result.tipo_simple_u.resultado = arg1.firstparam / arg1.secondparam;
	/*
	 * insert server code here
	 */

	return &result;
}

tipo_vector *
suma_vectores_1_svc(vectores arg1,  struct svc_req *rqstp)
{
	static tipo_vector  result;
	result.tipo_vector_u.resultado.resultado_val = (float*) malloc(arg1.v1.v1_len);
		result.tipo_vector_u.resultado.resultado_len = 0;

	for(int k = 0; k < arg1.v1.v1_len; k++){
		result.tipo_vector_u.resultado.resultado_val[k] = arg1.v1.v1_val[k] + arg1.v2.v2_val[k];
		result.tipo_vector_u.resultado.resultado_len++;
	}

	return &result;
}

tipo_vector *
resta_vectores_1_svc(vectores arg1,  struct svc_req *rqstp)
{
	static tipo_vector  result;
	result.tipo_vector_u.resultado.resultado_val = (float*) malloc(arg1.v1.v1_len);
		result.tipo_vector_u.resultado.resultado_len = 0;

	for(int k = 0; k < arg1.v1.v1_len; k++){
		result.tipo_vector_u.resultado.resultado_val[k] = arg1.v1.v1_val[k] - arg1.v2.v2_val[k];
		result.tipo_vector_u.resultado.resultado_len++;
	}

	return &result;
}


tipo_simple *
producto_escalar_1_svc(vectores arg1,  struct svc_req *rqstp)
{
	static tipo_simple  result;
	result.tipo_simple_u.resultado;
	for(int k = 0; k < arg1.v1.v1_len; k++){
		result.tipo_simple_u.resultado += arg1.v1.v1_val[k] * arg1.v2.v2_val[k];
	}

	/*
	 * insert server code here
	 */

	return &result;
}

tipo_vector *
multi_vector_escalar_1_svc(vectoryescalar arg1,  struct svc_req *rqstp)
{
	static tipo_vector  result;
 	result.tipo_vector_u.resultado.resultado_len = 0;
	result.tipo_vector_u.resultado.resultado_val = (float*) malloc(arg1.v.v_len);

	/*
	 * insert server code here
	 */
	for(int k = 0; k < arg1.v.v_len; k++){
		result.tipo_vector_u.resultado.resultado_val[k] = arg1.v.v_val[k] * arg1.num;
		result.tipo_vector_u.resultado.resultado_len++;
	}
	return &result;
}

tipo_vector *
divi_vector_escalar_1_svc(vectoryescalar arg1,  struct svc_req *rqstp)
{
	static tipo_vector  result;
 	result.tipo_vector_u.resultado.resultado_len = 0;
	result.tipo_vector_u.resultado.resultado_val = (float*) malloc(arg1.v.v_len);

	/*
	 * insert server code here
	 */
	for(int k = 0; k < arg1.v.v_len; k++){
		result.tipo_vector_u.resultado.resultado_val[k] = arg1.v.v_val[k] / arg1.num;
		result.tipo_vector_u.resultado.resultado_len++;
	}
	return &result;
}
